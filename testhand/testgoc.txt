#include <stdio.h>
#include <math.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/i2c.h"
#include "esp_log.h"
#include "mpu6050.h"
#include "esp_timer.h"
static const char *TAG = "DUAL_MPU6050";

// Cấu hình I2C
#define I2C_MASTER_SCL_IO    22
#define I2C_MASTER_SDA_IO    21
#define I2C_MASTER_NUM       I2C_NUM_0
#define MPU6050_ADDR_68      0x68    // AD0 = 0
#define MPU6050_ADDR_69      0x69    // AD0 = 1

// Bộ lọc MAHONY cho mỗi MPU6050
typedef struct {
    float q0, q1, q2, q3;  // Quaternion
    float integralFBx, integralFBy, integralFBz;  // Tích phân
    float Ki;  // Hệ số tích phân
    float Kp;  // Hệ số tỉ lệ
} MahonyFilter;

typedef struct {
    mpu6050_handle_t mpu;
    MahonyFilter filter;
    float roll, pitch, yaw;
    uint32_t last_time;
    char name[10];
} MPU6050_Device;

// Biến toàn cục cho 2 MPU6050
static MPU6050_Device mpu68;
static MPU6050_Device mpu69;

// Khởi tạo bộ lọc Mahony
static void mahony_init(MahonyFilter *f, float Kp_val, float Ki_val) {
    f->q0 = 1.0f;
    f->q1 = 0.0f;
    f->q2 = 0.0f;
    f->q3 = 0.0f;
    f->integralFBx = 0.0f;
    f->integralFBy = 0.0f;
    f->integralFBz = 0.0f;
    f->Kp = Kp_val;
    f->Ki = Ki_val;
}

// Cập nhật bộ lọc Mahony
static void mahony_update(MahonyFilter *f, 
                         float gx, float gy, float gz,  // Gyro (rad/s)
                         float ax, float ay, float az,  // Accel (g)
                         float dt) {                    // Thời gian delta (s)
    
    float recipNorm;
    float vx, vy, vz;
    float ex, ey, ez;
    
    // Chuẩn hóa gia tốc kế
    recipNorm = 1.0f / sqrt(ax * ax + ay * ay + az * az);
    ax *= recipNorm;
    ay *= recipNorm;
    az *= recipNorm;
    
    // Ước lượng hướng trọng lực từ quaternion
    vx = 2.0f * (f->q1 * f->q3 - f->q0 * f->q2);
    vy = 2.0f * (f->q0 * f->q1 + f->q2 * f->q3);
    vz = f->q0 * f->q0 - f->q1 * f->q1 - f->q2 * f->q2 + f->q3 * f->q3;
    
    // Lỗi ước lượng
    ex = (ay * vz - az * vy);
    ey = (az * vx - ax * vz);
    ez = (ax * vy - ay * vx);
    
    // Tích phân lỗi
    if (f->Ki > 0.0f) {
        f->integralFBx += f->Ki * ex * dt;
        f->integralFBy += f->Ki * ey * dt;
        f->integralFBz += f->Ki * ez * dt;
        
        // Áp dụng hiệu chỉnh tích phân
        gx += f->integralFBx;
        gy += f->integralFBy;
        gz += f->integralFBz;
    }
    
    // Áp dụng hiệu chỉnh tỉ lệ
    gx += f->Kp * ex;
    gy += f->Kp * ey;
    gz += f->Kp * ez;
    
    // Tích phân quaternion
    gx *= 0.5f * dt;
    gy *= 0.5f * dt;
    gz *= 0.5f * dt;
    
    float qa = f->q0;
    float qb = f->q1;
    float qc = f->q2;
    
    f->q0 += (-qb * gx - qc * gy - f->q3 * gz);
    f->q1 += (qa * gx + qc * gz - f->q3 * gy);
    f->q2 += (qa * gy - qb * gz + f->q3 * gx);
    f->q3 += (qa * gz + qb * gy - qc * gx);
    
    // Chuẩn hóa quaternion
    recipNorm = 1.0f / sqrt(f->q0 * f->q0 + f->q1 * f->q1 + 
                           f->q2 * f->q2 + f->q3 * f->q3);
    f->q0 *= recipNorm;
    f->q1 *= recipNorm;
    f->q2 *= recipNorm;
    f->q3 *= recipNorm;
}

// Chuyển quaternion sang góc Euler
static void quaternion_to_euler(float q0, float q1, float q2, float q3,
                               float *roll, float *pitch, float *yaw) {
    // Roll (x-axis rotation)
    float sinr_cosp = 2.0f * (q0 * q1 + q2 * q3);
    float cosr_cosp = 1.0f - 2.0f * (q1 * q1 + q2 * q2);
    *roll = atan2f(sinr_cosp, cosr_cosp) * 180.0f / M_PI;
    
    // Pitch (y-axis rotation)
    float sinp = 2.0f * (q0 * q2 - q3 * q1);
    if (fabs(sinp) >= 1.0f)
        *pitch = copysignf(M_PI / 2.0f, sinp) * 180.0f / M_PI;
    else
        *pitch = asinf(sinp) * 180.0f / M_PI;
    
    // Yaw (z-axis rotation)
    float siny_cosp = 2.0f * (q0 * q3 + q1 * q2);
    float cosy_cosp = 1.0f - 2.0f * (q2 * q2 + q3 * q3);
    *yaw = atan2f(siny_cosp, cosy_cosp) * 180.0f / M_PI;
}

// Khởi tạo I2C
static void i2c_master_init(void) {
    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = I2C_MASTER_SDA_IO,
        .scl_io_num = I2C_MASTER_SCL_IO,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = 400000,  // 400kHz
    };
    
    i2c_param_config(I2C_MASTER_NUM, &conf);
    i2c_driver_install(I2C_MASTER_NUM, conf.mode, 0, 0, 0);
}

// Khởi tạo MPU6050
static esp_err_t mpu6050_init_device(MPU6050_Device *device, uint8_t address, const char* name) {
    // Tạo handle cho MPU6050
    device->mpu = mpu6050_create(I2C_MASTER_NUM, address);
    
    if (device->mpu == NULL) {
        ESP_LOGE(TAG, "Không thể tạo MPU6050 tại địa chỉ 0x%02X", address);
        return ESP_FAIL;
    }
    
    // Đánh thức và cấu hình
    mpu6050_wake_up(device->mpu);
    mpu6050_config(device->mpu, ACCE_FS_4G, GYRO_FS_500DPS);
    
    // Khởi tạo bộ lọc Mahony
    mahony_init(&device->filter, 2.0f, 0.005f);
    
    // Khởi tạo các biến khác
    device->roll = 0;
    device->pitch = 0;
    device->yaw = 0;
    device->last_time = 0;
    snprintf(device->name, sizeof(device->name), "%s", name);
    
    ESP_LOGI(TAG, "Đã khởi tạo %s tại địa chỉ 0x%02X", device->name, address);
    return ESP_OK;
}

// Đọc và xử lý dữ liệu từ một MPU6050
static void process_mpu6050(MPU6050_Device *device) {
    mpu6050_acce_value_t acce;
    mpu6050_gyro_value_t gyro;
    
    // Đọc dữ liệu
    if (mpu6050_get_acce(device->mpu, &acce) != ESP_OK ||
        mpu6050_get_gyro(device->mpu, &gyro) != ESP_OK) {
        return;
    }
    
    // Tính thời gian delta
    uint32_t now = esp_timer_get_time();
    float dt = (device->last_time != 0) ? (now - device->last_time) / 1000000.0f : 0.001f;
    device->last_time = now;
    
    // Chuyển gyro từ độ/s sang rad/s
    float gx = gyro.gyro_x * M_PI / 180.0f;
    float gy = gyro.gyro_y * M_PI / 180.0f;
    float gz = gyro.gyro_z * M_PI / 180.0f;
    
    // Cập nhật bộ lọc Mahony
    mahony_update(&device->filter, gx, gy, gz, 
                 acce.acce_x, acce.acce_y, acce.acce_z, 
                 dt);
    
    // Chuyển quaternion sang góc Euler
    quaternion_to_euler(device->filter.q0, device->filter.q1, 
                       device->filter.q2, device->filter.q3,
                       &device->roll, &device->pitch, &device->yaw);
    
    // Giới hạn góc từ -180 đến 180 độ
    if (device->roll > 180.0f) device->roll -= 360.0f;
    if (device->roll < -180.0f) device->roll += 360.0f;
    if (device->pitch > 180.0f) device->pitch -= 360.0f;
    if (device->pitch < -180.0f) device->pitch += 360.0f;
    if (device->yaw > 180.0f) device->yaw -= 360.0f;
    if (device->yaw < -180.0f) device->yaw += 360.0f;
}

// Hiển thị góc của cả 2 MPU6050
static void display_angles(MPU6050_Device *mpu1, MPU6050_Device *mpu2) {
    printf("\n=== MPU6050 Góc Euler ===\n");
    printf("%s: Roll: %6.1f°, Pitch: %6.1f°, Yaw: %6.1f°\n", 
           mpu1->name, mpu1->roll, mpu1->pitch, mpu1->yaw);
    printf("%s: Roll: %6.1f°, Pitch: %6.1f°, Yaw: %6.1f°\n", 
           mpu2->name, mpu2->roll, mpu2->pitch, mpu2->yaw);
    
    // Tính chênh lệch giữa 2 cảm biến
    float diff_roll = fabs(mpu1->roll - mpu2->roll);
    float diff_pitch = fabs(mpu1->pitch - mpu2->pitch);
    float diff_yaw = fabs(mpu1->yaw - mpu2->yaw);
    
    printf("Chênh lệch: Roll: %5.1f°, Pitch: %5.1f°, Yaw: %5.1f°\n", 
           diff_roll, diff_pitch, diff_yaw);
    printf("================================\n");
}

// Task chính đọc 2 MPU6050
static void dual_mpu6050_task(void *pvParameters) {
    int display_count = 0;
    int read_count = 0;
    
    ESP_LOGI(TAG, "Bắt đầu đọc 2 MPU6050 với bộ lọc Mahony");
    
    while (1) {
        // Xử lý MPU6050 thứ nhất (0x68)
        process_mpu6050(&mpu68);
        read_count++;
        
        // Xử lý MPU6050 thứ hai (0x69)
        process_mpu6050(&mpu69);
        read_count++;
        
        // Hiển thị kết quả mỗi 0.5 giây (giả sử tần số ~200Hz)
        display_count++;
        if (display_count >= 100) {  // 100 lần đọc ≈ 0.5s @200Hz
            display_angles(&mpu68, &mpu69);
            display_count = 0;
        }
        
        // Delay nhỏ để tránh treo hệ thống
        vTaskDelay(1 / portTICK_PERIOD_MS);
    }
}

// Task kiểm tra cảm biến
static void sensor_check_task(void *pvParameters) {
    while (1) {
        mpu6050_acce_value_t acce;
        
        // Kiểm tra MPU6050 thứ nhất
        if (mpu6050_get_acce(mpu68.mpu, &acce) == ESP_OK) {
            // Cảm biến hoạt động bình thường
        } else {
            ESP_LOGW(TAG, "MPU6050 (0x68) không phản hồi!");
        }
        
        // Kiểm tra MPU6050 thứ hai
        if (mpu6050_get_acce(mpu69.mpu, &acce) == ESP_OK) {
            // Cảm biến hoạt động bình thường
        } else {
            ESP_LOGW(TAG, "MPU6050 (0x69) không phản hồi!");
        }
        
        vTaskDelay(2000 / portTICK_PERIOD_MS);  // Kiểm tra mỗi 2 giây
    }
}

void app_main(void) {
    ESP_LOGI(TAG, "Khởi động hệ thống 2 MPU6050");
    
    // Khởi tạo I2C
    i2c_master_init();
    ESP_LOGI(TAG, "I2C đã khởi tạo");
    
    // Khởi tạo MPU6050 thứ nhất (0x68)
    if (mpu6050_init_device(&mpu68, MPU6050_ADDR_68, "MPU68") != ESP_OK) {
        ESP_LOGE(TAG, "Lỗi khởi tạo MPU6050 tại 0x68");
        return;
    }
    
    vTaskDelay(50 / portTICK_PERIOD_MS);
    
    // Khởi tạo MPU6050 thứ hai (0x69)
    if (mpu6050_init_device(&mpu69, MPU6050_ADDR_69, "MPU69") != ESP_OK) {
        ESP_LOGE(TAG, "Lỗi khởi tạo MPU6050 tại 0x69");
        return;
    }
    
    // Chờ 1 giây để cảm biến ổn định
    ESP_LOGI(TAG, "Chờ cảm biến ổn định...");
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    
    // Tạo task đọc cảm biến
    xTaskCreate(dual_mpu6050_task, "dual_mpu_task", 4096, NULL, 5, NULL);
    
    // Tạo task kiểm tra cảm biến (tùy chọn)
    xTaskCreate(sensor_check_task, "sensor_check", 2048, NULL, 1, NULL);
    
    ESP_LOGI(TAG, "Hệ thống đã sẵn sàng. Đọc dữ liệu từ 2 MPU6050...");
}